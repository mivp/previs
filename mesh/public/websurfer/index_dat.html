<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <!--
             Monash Web Surfer: web surface visualisation utility 
             (c) Owen Kaluza & David Barnes, Monash University 2014

             This program is free software: you can redistribute it and/or modify
             it under the terms of the GNU General Public License as published by
             the Free Software Foundation, either version 3 of the License, or
             (at your option) any later version.

             This program is distributed in the hope that it will be useful,
             but WITHOUT ANY WARRANTY; without even the implied warranty of
             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
             GNU General Public License for more details.

             You should have received a copy of the GNU General Public License
             along with this program.  If not, see <http://www.gnu.org/licenses/>.

             Info:
           - Provide model directory on URL, eg: index.html?model=mymodel
           - Will attempt to load mymodel/model.tok listing objects to load, description and parameters
           - THREEx extensions provide optional additional features but can be removed
           - OBJLoader3.js is very slightly modified from original to provide additional parameter in callback
           - TrackballControls.js modified to provide primitive touchscreen support

             Updates, O.K: Dec 2013 / Jan 2014:
           - Views menu added to select additional views defined in model.tok
           - Dropbdown menu interface, touchscreen compatible
           - OBJLoader loaded callback passes id directly so we don't have to iterate the list
           - Fixed object intersection to use the canvas area rather than entire window for calculations to improve accuracy
           - Removed jquery as only used for the object labels, updated label display to work without it and fixed timeout
           - Modified animation loop to display only when camera changed, camera state stored as string and compared
           - Minor adjustments to loading status and lighting, initial zoom set to slightly wider angle

             Updates, O.K: Apr 2014:
           - Upgraded to Three.js v66
           - New version of TrackballControls has support for touchscreen + wheel so stripped out our old code for this
           - Warning info and confirm when WebGL not available as CanvasRenderer can be extremely slow
           - Added background image display while loading, background.png in model directory

           -->

        <title>Monash Web Surfer - surface visualisation (O.L. Kaluza &amp; D.G. Barnes</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
     

        <style type="text/css">
            body {
            padding   : 0;
            margin    : 0;
            color     : #ccc;
            background-color: #000;
            font-family  : arial;
            font-size  : 100%;
            overflow  : hidden;
            background-position: center; 
            background-repeat: no-repeat; 
            background-attachment:fixed;
            }

            #heading {
            background-color: #000;
            width      : 100%;
            margin     : 0;
            }

            #title, #status {
            padding    : 5px;
            margin     : 0px 5px;
            }

            #status {
            color       : #f55;
            font-weight : bold;
            position: absolute;
            top: 5%; left: 1%;
            }

            .dropdown {
            float: right;
            border-color: #222;
            border-style: groove;
            border-width: 1px;
            border-radius: 4px;
            padding: 4px;
            margin: 1px;
            font-size: 85%;
            background-color: #000;
            }

            .menu {
            display: none; 
            position: absolute;
            right: 2px;
            top: 28px;
            overflow: hidden; 
            text-align: left;
            background-color: #222;
            border-color: #222;
            border-style: groove;
            border-width: 1px;
            padding: 5px;
            font-size: 85%;
            }

            .dropdown:hover {background-color: #555;}
            .dropdown.active {background-color: #ddc;}

            .menu input,label { 
            padding: 5px 0px;
            margin: 5px;
            vertical-align: middle; 
            }

            .menu.active {display: block;}

            #label {
            position: absolute;
                top: 15%;
                color: #111;
            background-color: #dc0;
            display: none;
            border-color: #111;
            border-style: groove;
            border-width: 1px;
            padding: 4px;
            }

            #container {
            width : 100%;
            height : 100%;
            }

         #canvas {
            background-color:  #000;
            width : 100%;
            height : 100%;
            }

            #footing {
            position : absolute;
            background-color: #333;
            bottom : 0;
            width : 100%;
            padding : 5px;
            text-align : left;
            font-size: 85%;
            margin     : 0;
            overflow  : hidden;
            }

            #nowebgl {
            position:fixed;
            width:400px;
            top:50%; left:50%;
            margin:-100px 0 0 -200px; /* [-(height/2)px 0 0 -(width/2)px] */
            display:none; z-index: 100; border: none; 
            padding: 5px; overflow-y: auto;
            font-family  : monospace;
            font-size  : 13px;
            font-weight  : normal;
            text-align  : center;
            background  : #fff;
            color  : #ccc;
            opacity: 0.75;
            }

            /* Hide footer on phone screen */
            @media (max-width: 700px) {
            #footing {display: none;}
            }
        </style>
          <!--       <style src="old.css"></style>    -->
      <!--    <style src="css/sharevol.css"></style> -->

    </head>

    <body>
        <script src="lib/three.min.js"></script>
        <script src="lib/Detector.js"></script>
        <script src="lib/OBJLoader3.js"></script>
        <script src="lib/Stats.js"></script>
        <script src="lib/DAT.GUI.min.js"></script>

         <script src="js/OrbitControls.js"></script> 
        <script src="lib/THREEx.screenshot.js"></script>
        <script src="lib/THREEx.FullScreen.js"></script>
        <script src="lib/THREEx.WindowResize.js"></script>
        <script src="lib/TrackballControls.js"></script>

        <script src="lib/info.js"></script>
        <div id="infoButton"></div>
        <div id="infoBox" title="Demo Information">
            This is a new demo for Websurfer inside Previs
            <a href="http://mivp.github.com/previs/">http://mivp.github.io/previs/</a>
        </div>



        <div id="heading">
            <!-- <menu> 
                <li>
                    <button type=menu value="File" menu="filemenu">
                        <menu id="filemenu" type="context">
                            <menuitem onclick="fnew()" label="New...">
                                <menuitem onclick="fopen()" label="Open...">
                                    <menuitem onclick="fsave()" label="Save">
                                        <menuitem onclick="fsaveas()" label="Save as...">
                                        </menu>
                </li>
                <li>
                    <button type=menu value="Edit" menu="editmenu">
                        <menu id="editmenu" type="context">
                            <menuitem onclick="ecopy()" label="Copy">
                                <menuitem onclick="ecut()" label="Cut">
                                    <menuitem onclick="epaste()" label="Paste">
                                    </menu>
                </li>
                <li>
                    <button type=menu value="Help" menu="helpmenu">
                        <menu id="helpmenu" type="context">
                            <menuitem onclick="location='help.html'" label="Help">
                                <menuitem onclick="location='about.html'" label="About">
                                </menu>
                </li>
                            </menu> -->
                            <button type=menu menu=editmenu>Commands...</button>
                            <menu type="context" id="editmenu">
                             <!--    <menuitem type="radio" radiogroup="alignment" checked="checked"
                                          label="Left" icon="icons/alL.png" onclick="setAlign('left')">
                                    <menuitem type="radio" radiogroup="alignment"
                                              label="Center" icon="icons/alC.png" onclick="setAlign('center')">
                                        <menuitem type="radio" radiogroup="alignment"
                                                  label="Right" icon="icons/alR.png" onclick="setAlign('right')"> -->
                                            <hr>
                                            <menuitem type="command" disabled
                                                      label="Publish" icon="icons/pub.png" onclick="publish()">
                                            </menu>
             <div class="dropdown" onclick="toggleMenu(this);">Help
                <div class="menu" onclick="event.stopPropagation();" id="help"></div>
            </div>
            <div class="dropdown" onclick="toggleMenu(this);">Reset
                <div class="menu" onclick="event.stopPropagation();" id="reset"></div>
            </div>
       
            <div class="dropdown" onclick="toggleMenu(this);">Groups
                <div class="menu" onclick="event.stopPropagation();" id="groups"></div>
            </div>
            <div class="dropdown" onclick="toggleMenu(this);">Views
                <div class="menu" onclick="event.stopPropagation();" id="views"></div>


            </div>
            <div id="title">WebSurfer (initialising, please wait ...)</div>
        </div>

        <div id="nowebgl">
            Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />
            Find out how to get it <a href="http://get.webgl.org/">here</a><br />
            Click <a href="javascript:init(true);">here</a> to show the model anyway, it may be very slow to display and update.
        </div>

        <div id="status"></div>
        <div id="label" class="label">(no selection)</div>

        <div id="container">
            <canvas id="canvas"></canvas>
        </div>

        <div id="footing">WebSurfer (initialising, please wait ...)</div>

        <script type="text/javascript">
         //header('content-type: application/json; charset=utf-8');
         //header("access-control-allow-origin: *");

         // Global vars
         var model = getUrlVars()["model"];
         var     ObjInfo = makeStruct("name groups filename r g b a");
         var     objs = [];
         var     GrpInfo = makeStruct("name id init");
         var     grps = [];
         var     views = [];
         var     title_frag = "WebSurfer";
         var     footer_txt = "WebSurfer";
         var     PosInfo = makeStruct("x y z");
         var     background = new PosInfo(0.076, 0.076, 0.076);
         var     ambientLight = new PosInfo(0.25,0.25,0.25);
         var     headLight = new PosInfo(0.67,0.67,0.67);
         var     prevcam = "";  //Save camera to detect if redraw required
         var     projector = new THREE.Projector();
         var     menu = null;
         var scene, renderer, camera, controls, headlight;
         var stats;
            var ref_obj = [];
            var BBoxInfo=makeStruct("xmin ymin zmin xmax ymax zmax");
         var BBox=[];
         var MeshObj = function(l,r,g,b,a){
             this.label=l;
             this.color = [r, g, b, a];
             this.show=true;
         };

         // init the scene
         function init(force) {

             var container = document.getElementById('container');
             //Use existing canvas element rather than letting Three.js create one
             var canvas = document.getElementById("canvas");
             //Use a pre-rendered background if provided
             //document.body.style.backgroundImage = "url(" + model + "/background.png)";

             //Detect renderer
             if (Detector.webgl) {
                 renderer = new THREE.WebGLRenderer({
                     "canvas"    : canvas,
                     "alpha"    : true,
                     "antialias"    : true,
                     "preserveDrawingBuffer"  : true  // to allow screenshot
                 });
                 renderer.setClearColor(0xf9f9f9);

             } else {
                 if (!force) {
                     document.getElementById("nowebgl").style.display = "block";
                     return;
                 }
                 document.getElementById("nowebgl").style.display = "none";
                 renderer = new THREE.CanvasRenderer({"canvas"    : canvas});
             }

             renderer.setSize( window.innerWidth, window.innerHeight );
             document.getElementById("title").innerHTML = title_frag;

             //Create scene
             scene = new THREE.Scene();

             var fov = 40; //Field of view
             camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 10000);

             //Camera contol
             var container = document.getElementById("container");
             controls = new THREE.TrackballControls(camera, container);
             controls.rotateSpeed = 1.0;
             controls.zoomSpeed = 1.2;
             controls.panSpeed = 0.8;
             controls.noZoom = false;
             controls.noPan = false;
             controls.staticMoving = true;
             controls.dynamicDampingFactor = 0.3;
             controls.keys = [ 65, 83, 68 ];

             if (views.length == 0) {
                 //Default camera
                 views.push({"name" : "Default", 
                             "position" : [0,0,1500],
                             "lookat" : [0,0,0],
                             "up" : [0,1,0]
                 });
             }

             setCamera(0);
             scene.add(camera);

             // grid
				     var gridHelper = new THREE.GridHelper( 14, 28, 0x303030, 0x303030 );
				     gridHelper.position.set( 0, - 0.04, 0 );
				     scene.add( gridHelper );





             //Scroll wheel events
             //window.addEventListener('DOMMouseScroll', mousewheel, false);
             //window.addEventListener('mousewheel', mousewheel, false);
             //Redisplay on resize (clearing "prevcam" forces redraw)
	           window.addEventListener('resize', function() {prevcam = ""; controls.handleResize();}, false);
             //Click to select object
             container.addEventListener('click', onDocumentMouseDown, false );

             //Window resize support
             THREEx.WindowResize.bind(renderer, camera);
             //'p' to make screenshot
             THREEx.Screenshot.bindKey(renderer);
             //'f' to go fullscreen where supported
             if (THREEx.FullScreen.available())
                 THREEx.FullScreen.bindKey();
             // STATS
	           stats = new Stats();
	           stats.domElement.style.position = 'absolute';
	           stats.domElement.style.bottom = '0px';
	           stats.domElement.style.zIndex = 100;
	           container.appendChild( stats.domElement );

             //Lighting... ambient and headlight
             var ambcol = new THREE.Color(0);
             ambcol.setRGB(ambientLight.x, ambientLight.y, ambientLight.z);
             var ambient = new THREE.AmbientLight( ambcol.getHex() );
             scene.add(ambient);

             var headcol = new THREE.Color(0);
             headcol.setRGB(headLight.x, headLight.y, headLight.z);
             headlight = new THREE.PointLight( headcol.getHex() );
             headlight.position = camera.position;
             scene.add(headlight);
/*
// FLOOR

	          var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -0.5;
	floor.rotation.x = Math.PI / 2;
	floor.name = "Checkerboard Floor";
	scene.add(floor);
*/
             //Add objects to scene
             var loader = new THREE.OBJLoader();
             var nloaded = 0;
             var nobjs = objs.length;

             for (var i = 0; i < nobjs; i++) {
                 var callback = function(object, idx) {
                     //Setup the loaded object properties and add to the scene

                     object.children[0].material.color.setRGB(objs[idx].r, objs[idx].g, objs[idx].b);

                     if (objs[idx].a < 0.999) {
                         object.children[0].material.transparent = true;
                         object.children[0].material.opacity = objs[idx].a;
                     } else {
                         object.children[0].material.transparent = false;
                         object.children[0].material.opacity = 1.0;
                     }
                     
                     // Required for object intersect to work...
                     // http://stackoverflow.com/questions/11205784/three-js-using-projector-and-ray-to-selected-a-vertex
                     object.children[0].geometry.computeFaceNormals();
                     var geometry = object.children[0].geometry;
                     //THREE.GeometryUtils.center(geometry);
                     //var material = new THREE.MeshLambertMaterial({color: 0xffaa77, shading: THREE.FlatShading, vertexColors: THREE.VertexColors });

                     // save ref for later use, e.g. model tree switch in/out of render
                     ref_obj[idx] = new THREE.Mesh(geometry, object.children[0].material);

                     scene.add( ref_obj[idx] );

                     nloaded += 1;
                     if (nloaded == nobjs) {
                         window.obj = ref_obj[idx];
                         document.getElementById("status").style.display = "none";
                         document.getElementById("container").style.display = "block";
                         applyCheckboxState();
//                         document.body.style.backgroundImage = "";

                         animate();
                     } else {
                         document.getElementById("status").innerHTML = "(loaded " + nloaded + "/" + nobjs + " ... )";
                     }  
                 }

                 //Load the object, passing index so can be passed to callback
                 loader.load(objs[i].filename, callback, i);
             }
             //Grid Helper
            /* var helper = new THREE.GridHelper( 200, 40, 0x0000ff, 0x808080 );
				     helper.position.y = 0;
				     scene.add( helper );

             var size = 10;
             var step = 1;

             var gridHelper = new THREE.GridHelper( size, step );
             scene.add( gridHelper );
             */
             // Bounding Box
             var hex = = 0xff0000;
             var bbox = new THREE.BoundingBoxHelper( scene, hex );
             bbox.update();
             scene.add( bbox );
             var axisHelper = new THREE.AxisHelper( 5 );
             scene.add( axisHelper );
         }

         function getUrlVars() {
             var vars = {};
             var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
                 vars[key] = value;
             });
             return vars;
         }

         function makeStruct(names) {
             var names = names.split(' ');
             var count = names.length;
             function constructor() {
                 for (var i = 0; i < count; i++) {
                     this[names[i]] = arguments[i];
                 }
             }
             return constructor;
         }

         function parseTuple(x_str,y_str,z_str, as_array) {
             var x = parseFloat(x_str);
             var y = parseFloat(y_str);
             var z = parseFloat(z_str);
             if (as_array)
                 return [x,y,z];
             else
                 return (new PosInfo(x,y,z));
         }

         // parse the token file
         function parseTokFile(textchunk) {
             lines = textchunk.split("\n");
             for (var i = 0; i < lines.length; i++) {
                 bits = lines[i].split(":");

                 if (bits[0] == "title_frag") {
                     // paste any remainder of line split on ":" back together
                     res = bits[1];
                     for (var k = 2; k < bits.length; k++) {
                         res = res + ":" + bits[k];
                     }
                     title_frag = res;
                 } else if (bits[0] == "footer_txt") {
                     // paste any remainder of line split on ":" back together
                     res = bits[1];
                     for (var k = 2; k < bits.length; k++) {
                         res = res + ":" + bits[k];
                     }
                     footer_txt = res;

                 } else if (bits[0] == "camera_position") {
                     views.push({"name" : "Default", "position" : parseTuple(bits[1], bits[2], bits[3], true)});
                 } else if (bits[0] == "camera_lookat") {
                     if (views.length > 0) views[0].lookat = parseTuple(bits[1], bits[2], bits[3], true);
                 } else if (bits[0] == "camera_up") {
                     if (views.length > 0) views[0].up = parseTuple(bits[1], bits[2], bits[3], true);
                 } else if (bits[0] == "background") {
                     background = parseTuple(bits[1], bits[2], bits[3]);
                 } else if (bits[0] == "ambientLight") {
                     ambientLight = parseTuple(bits[1], bits[2], bits[3]);
                 } else if (bits[0] == "headLight") {
                     headLight = parseTuple(bits[1], bits[2], bits[3]);
                 } else if (bits[0] == "views") {
                     views.push({"name" : bits[1], 
                                 "position" : JSON.parse("[" + bits[2] + "]"),
                                 "lookat" : JSON.parse("[" + bits[3] + "]"),
                                 "up" : JSON.parse("[" + bits[4] + "]")
                     });
                 } else if (bits[0] == "grps") {
                     grps.push(new GrpInfo(bits[1], bits[2], bits[3] == "true" || parseInt(bits[3]) == 1));
                 } else if (bits[0] == "objs") {
                     objs.push(new ObjInfo(bits[1], bits[2], model + "/" + bits[3], bits[4], bits[5], bits[6], bits[7]));
                 } else if (bits[0] == "bb") {
                     BBox.push(new BBInfo(bits[1], bits[2], bits[3], bits[4], bits[5], bits[6]));
                 }
             }
         }

         // init the group checkboxes
         function initGroups() {
            for (var i = 0; i < grps.length; i++) {
                addMenuItem("groups", "checkbox", grps[i].id, grps[i].name, grps[i].name, grps[i].init, 
                            function() {applyCheckboxState(); render();});
                addMenuItem("reset", "checkbox", grps[i].id, grps[i].name, grps[i].name, grps[i].init, 
                            function() {applyCheckboxState(); render();});
            }
         }

         

         // init camera view selection
         function initViews() {
             for (var i = 0; i < views.length; i++) {
                 addMenuItem("views", "radio", "view_" + i, "views", views[i].name, i==0, Function("setCamera(" + i + ");"));
             }
         }

         function addMenuItem(parentid, type, id, name, text, checked, onclick) {
             //Dynamically add items to the menus
             var container = document.getElementById(parentid);
             var item = document.createElement("input");
             item.id = id;
             item.type = type;
             item.name = name;
             item.onclick = onclick;
             item.checked = checked;
             //Create the label
             var label = document.createElement("label");
             label.appendChild(label.ownerDocument.createTextNode(text));
             //Associate with input
             label.setAttribute("for", item.id);
             //Add controls
             if (container.childNodes.length > 0)
                 container.appendChild(document.createElement("hr"));
             container.appendChild(item);
             container.appendChild(label);
         }

         // apply the checkbox state to the model
         // this shows/hides defined groups of objects
         function applyCheckboxState() {
             var i, j;
             for (j = 0; j < grps.length; j++) {
                 var chkBox = document.getElementById(grps[j].id);
                 state = chkBox.checked;
                 for (i = 0; i < objs.length; i++) {
                     if (objs[i].groups == grps[j].id) {
                         ref_obj[i].visible = state;
                     }
                 }
             }
         }

         function setCamera(view_id) {
             var v = views[view_id];
             // ensure camera.up is orthog to lookat-position
             var dir = new THREE.Vector3(v.lookat[0] - v.position[0],
                                         v.lookat[1] - v.position[1],
                                         v.lookat[2] - v.position[2]);

             //Add camera
             camera.position.set(v.position[0], v.position[1], v.position[2]);
             camera.up.set(v.up[0], v.up[1], v.up[2]);

             // N.B. point to look at / rotate about is PER MODEL
             controls.target.set(v.lookat[0], v.lookat[1], v.lookat[2]);
         }

         //Animation loop
         function animate() {
             //Request animation loop
             requestAnimationFrame(animate);

             //Update camera
             controls.update();
             //String representation of view parameters
             var cam = JSON.stringify(camera.position);
             //Compare to cached camera string and refresh only when changed
             //(This makes it lighter on the CPU)
             if (prevcam.length != cam.length || prevcam != cam) {
                 //Update display
                 headlight.position = (camera.position);

                 render();

                 prevcam = JSON.stringify(camera.position);
             }
             update()
         }
         function update()
         {
	           controls.update();
	           stats.update();
         }

         //Render the scene
         function render() {
             renderer.render( scene, camera );
         }

         function toggleMenu(el) {
             //Click to display/hide a menu, also hide other open menus
             if (el.childNodes.length < 2) return;
             var child = el.childNodes[1];
             if (menu) {
                 var m = menu;
                 menu = null;
                 toggleMenu(m);
                 if (m == el) return;
             }
             
             if (child.className == "menu") {
                 child.className += " active"
                 el.className += " active"
                 menu = el;
             } else {
                 child.className = "menu"
                 el.className = "dropdown"
                 menu = null;
             }
         }

         // https://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
         function makeTextSprite( message, parameters )
         {
	           if ( parameters === undefined ) parameters = {};
	           
	           var fontface = parameters.hasOwnProperty("fontface") ? 
		                        parameters["fontface"] : "Arial";
	           
	           var fontsize = parameters.hasOwnProperty("fontsize") ? 
		                        parameters["fontsize"] : 18;
	           
	           var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		                               parameters["borderThickness"] : 4;
	           
	           var borderColor = parameters.hasOwnProperty("borderColor") ?
		                           parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	           
	           var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		                               parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

	           var spriteAlignment = THREE.SpriteAlignment.topLeft;
		         
	           var canvas = document.createElement('canvas');
	           var context = canvas.getContext('2d');
	           context.font = "Bold " + fontsize + "px " + fontface;
             
	           // get size data (height depends only on font size)
	           var metrics = context.measureText( message );
	           var textWidth = metrics.width;
	           
	           // background color
	           context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								                 + backgroundColor.b + "," + backgroundColor.a + ")";
	           // border color
	           context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								                 + borderColor.b + "," + borderColor.a + ")";

	           context.lineWidth = borderThickness;
	           roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
	           // 1.4 is extra height factor for text below baseline: g,j,p,q.
	           
	           // text color
	           context.fillStyle = "rgba(0, 0, 0, 1.0)";

	           context.fillText( message, borderThickness, fontsize + borderThickness);
	           
	           // canvas contents will be used for a texture
	           var texture = new THREE.Texture(canvas) 
	           texture.needsUpdate = true;

	           var spriteMaterial = new THREE.SpriteMaterial( 
		             { map: texture, useScreenCoordinates: false, alignment: spriteAlignment } );
	           var sprite = new THREE.Sprite( spriteMaterial );
	           sprite.scale.set(100,50,1.0);
	           return sprite;	
         }

         // function for drawing rounded rectangles
         function roundRect(ctx, x, y, w, h, r) 
         {
             ctx.beginPath();
             ctx.moveTo(x+r, y);
             ctx.lineTo(x+w-r, y);
             ctx.quadraticCurveTo(x+w, y, x+w, y+r);
             ctx.lineTo(x+w, y+h-r);
             ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
             ctx.lineTo(x+r, y+h);
             ctx.quadraticCurveTo(x, y+h, x, y+h-r);
             ctx.lineTo(x, y+r);
             ctx.quadraticCurveTo(x, y, x+r, y);
             ctx.closePath();
             ctx.fill();
	           ctx.stroke();   
         }

         function onDocumentMouseDown( event ) {
             //Get mouse coords relative to canvas
             var x;
             var y;
             if (event.pageX || event.pageY) { 
                 x = event.pageX;
                 y = event.pageY;
             }
             else { 
                 x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
                 y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
             } 
             x -= renderer.domElement.offsetLeft;
             y -= renderer.domElement.offsetTop;

             var vector = new THREE.Vector3(
                 ( x / renderer.domElement.width ) * 2 - 1,
                 - ( y / renderer.domElement.height ) * 2 + 1,
                 1.0
             );
             
             projector.unprojectVector(vector, camera);

             var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
             var intersects = ray.intersectObjects(ref_obj, true);

             //This will display the first intersected object
             var found = false;
             var found_id = -1;
             if (intersects.length > 0) {
                 for (var z = 0; z < intersects.length && !found; z++) {
                     var z_id = intersects[z].object.id;
                     for (var x = 0; x < ref_obj.length && !found; x++) {
                         if (ref_obj[x].visible && ref_obj[x].id == z_id) {
                             found = true;
                             found_id = x;
                         }
                     }
                 }
             }

             if (found) {
                 var label = document.getElementById("label");
                 label.innerHTML = objs[found_id].name;
                 label.style.display = "inline";
                 //Display label for 4 seconds or until another element picked
                 if (label.timer) clearTimeout(label.timer);
                 label.timer = setTimeout(function() {label.style.display = 'none';}, 4000);

                 var spritey = makeTextSprite( objs[found_id].name, 
		                                           { fontsize: 32, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0} } );
	               spritey.position.set(55,105,55);
	               scene.add( spritey );

             }
         }

         //Start loading the model...
         loadModel();

         function loadModel() {
             
             var model_tok = model + "/model.tok";
             var tokFile = new XMLHttpRequest();
             tokFile.overrideMimeType('text/plain');
             tokFile.onreadystatechange = function() {
                 if (tokFile.readyState == 4) {
                     if (tokFile.status == 200 || tokFile.status == 0) {
                         //Document found on server, ready to parse...
                         parseTokFile(tokFile.responseText);
                         document.getElementById("status").innerHTML = "(loading ... )";
                         document.getElementById("footing").innerHTML = footer_txt;
                         //Read user-defined groups/views then load the scene
                         initGroups();
                         initViews();
                         init();
                     }
                 }
             }

             tokFile.open("GET", model_tok, true);
             tokFile.send(null);
         }


        </script>

  
    </body>
</html>
